# MYMQOS 分屏文本编辑器 - 项目技术文档

## 项目概述

MYMQOS 是一个基于龙芯 LoongArch64 架构的简易操作系统内核，实现了一个带有**分屏功能的文本编辑器**。该项目运行在 QEMU 虚拟机上，通过键盘中断实现实时输入处理，并在 1280×800 分辨率的显示器上呈现双窗口编辑界面。

### 项目特点

- **双窗口分屏编辑**：屏幕分为上下两个独立编辑区域
- **虚拟缓冲区管理**：支持内容滚动和历史查看
- **实时键盘中断处理**：支持字符输入、方向键移动、退格删除
- **光标可视化**：实时显示当前输入位置
- **焦点切换**：通过 TAB 键在上下窗口间切换
- **颜色切换**：支持多种字符颜色

---

## 成员分工

| 模块                   | 负责人 | 主要职责                                   |
| ---------------------- | ------ | ------------------------------------------ |
| **逻辑控制模块** | 成员 A | 键盘中断处理、光标移动逻辑、字符插入删除   |
| **显示输出模块** | 成员 B | 虚拟缓冲区管理、定时刷新逻辑、分屏功能实现 |

---

## 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                      用户输入 (键盘)                      │
└───────────────────────────┬─────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│              键盘中断处理 (成员 A)                        │
│    key_interrupt() → handle_editor_input()              │
└───────────────────────────┬─────────────────────────────┘
                            │
            ┌───────────────┴───────────────┐
            ▼                               ▼
┌───────────────────────┐       ┌───────────────────────┐
│   光标移动逻辑 (成员 A)  │       │  字符操作逻辑 (成员 A)  │
│   方向键处理            │       │  insert_char_at()     │
│   边界检测              │       │  delete_char_at()     │
└───────────┬───────────┘       └───────────┬───────────┘
            │                               │
            └───────────────┬───────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│              虚拟缓冲区 (成员 B)                          │
│         video_buffer[200][160]                          │
└───────────────────────────┬─────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│              屏幕刷新 (成员 B)                            │
│    flush_screen() → write_char_with_color()             │
└───────────────────────────┬─────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   显存 VRAM (0x40000000)                 │
└─────────────────────────────────────────────────────────┘
```

---

# 第一部分：逻辑控制模块 (成员 A)

## 1. 键盘中断处理

### 1.1 中断入口：`exception_handler` (汇编)

**文件位置**：`kernel/excp/exception_handler.S`

```asm
exception_handler:
    addi.d $sp, $sp, -0xf0      # 分配栈空间 240 字节
    store_load_regs st.d         # 保存所有寄存器到栈
    bl do_exception              # 调用 C 函数处理异常
    store_load_regs ld.d         # 恢复所有寄存器
    addi.d $sp, $sp, 0xf0        # 释放栈空间
    ertn                         # 异常返回
```

**实现原理**：

- 当中断发生时，CPU 自动跳转到 `CSR_EENTRY` 寄存器指向的地址
- 汇编代码负责保存现场（所有通用寄存器），确保中断处理不破坏原有程序状态
- 调用 C 函数 `do_exception()` 进行具体处理
- 处理完成后恢复现场并使用 `ertn` 指令返回中断点

**为什么需要这样实现**：

- 中断可能在任何时刻发生，必须保存所有寄存器状态
- 使用宏 `store_load_regs` 简化了 30 个寄存器的保存/恢复操作
- 汇编与 C 语言协作，既保证了底层控制，又提高了开发效率

---

### 1.2 中断分发：`do_exception()`

**文件位置**：`kernel/excp/exception.c`

```c
void do_exception()
{
    unsigned int estat;
    unsigned long irq;

    estat = read_csr_32(CSR_ESTAT); /* 获取中断状态 */

    if (estat & CSR_ESTAT_IS_TI) /* 定时器中断 */
    {
        write_csr_32(CSR_TICLR_CLR, CSR_TICLR);
        timer_interrupt();
    }

    if (estat & CSR_ESTAT_IS_HWI0) /* 硬件中断 0 */
    {
        irq = read_iocsr(IOCSR_EXT_IOI_SR);
        if (irq & (1UL << KEYBOARD_IRQ_HT)) /* 键盘中断 */
        {
            write_iocsr(1UL << KEYBOARD_IRQ_HT, IOCSR_EXT_IOI_SR);
            key_interrupt();
        }
    }
}
```

**实现原理**：

- 读取 `ESTAT` 寄存器判断中断类型
- 键盘中断通过硬件中断线 0 (HWI0) 触发
- 使用 W1C（Write 1 to Clear）机制清除中断标志

**为什么需要这样实现**：

- LoongArch 架构使用统一的异常入口，需要软件判断具体中断类型
- 必须先清除中断标志，否则会不断触发中断
- 将定时器中断和键盘中断分开处理，便于后续扩展

---

### 1.3 键盘扫描码处理：`key_interrupt()`

**文件位置**：`kernel/excp/exception.c`

```c
void key_interrupt()
{
    unsigned char c;
    static bool is_break = false;    /* 断码标记 */
    static bool is_extended = false; /* 扩展码标记 */

    c = *(volatile unsigned char *)L7A_I8042_DATA;

    if (c == 0xE0) { is_extended = true; return; }
    if (c == 0xF0) { is_break = true; return; }
    if (is_break)  { is_break = false; is_extended = false; return; }
    if (c == 0x58) caps_locked = !caps_locked; /* CapsLock */

    if (is_extended) {
        is_extended = false;
        handle_editor_input(c); /* 处理方向键等扩展键 */
        return;
    }
    handle_editor_input(c);
}
```

**键盘映射表**：

```c
char keys_map[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '`', 0,
    0, 0, 0, 0, 0, 'q', '1', 0, 0, 0, 'z', 's', 'a', 'w', '2', 0,
    // ... 完整的 PS/2 扫描码到 ASCII 的映射
};
```

**实现原理**：

- PS/2 键盘协议：按键按下发送通码，释放发送 `0xF0` + 通码
- 扩展键（方向键等）以 `0xE0` 为前缀
- 使用静态变量保存状态机状态

**为什么需要这样实现**：

- PS/2 键盘协议是多字节协议，需要状态机解析
- 只响应按键按下事件，忽略释放事件，避免重复处理
- 区分扩展键和普通键，方向键属于扩展键

---

## 2. 光标移动逻辑

### 2.1 编辑器输入处理：`handle_editor_input()`

**文件位置**：`kernel/excp/exception.c`

```c
void handle_editor_input(int scan_code)
{
    int virt_y = get_current_virt_y();
    int line_len = get_line_length(virt_y);
    int screen_height = current_focus->end_line - current_focus->start_line + 1;

    if (scan_code == 0x75) {      /* Up：向上移动 */
        if (current_focus->cur_y > current_focus->start_line)
            current_focus->cur_y--;
    }
    else if (scan_code == 0x72) { /* Down：向下移动 */
        if (current_focus->cur_y < current_focus->end_line)
            current_focus->cur_y++;
    }
    else if (scan_code == 0x6B) { /* Left：向左移动 */
        if (current_focus->cur_x > 0) {
            current_focus->cur_x--;
        } else {
            /* 行首跳转到上一行末尾 */
            if (current_focus->cur_y > current_focus->start_line) {
                current_focus->cur_y--;
                int prev_virt_y = get_current_virt_y();
                current_focus->cur_x = get_line_length(prev_virt_y);
            }
        }
    }
    else if (scan_code == 0x74) { /* Right：向右移动 */
        if (current_focus->cur_x < line_len) {
            current_focus->cur_x++;
        } else {
            /* 行末跳转到下一行开头 */
            if (current_focus->cur_y < current_focus->end_line) {
                int next_virt_y = get_current_virt_y() + 1;
                if (get_line_length(next_virt_y) > 0) {
                    current_focus->cur_y++;
                    current_focus->cur_x = 0;
                }
            }
        }
    }
    // ... 其他按键处理
    flush_screen(current_focus); /* 调用成员 B 的刷新函数 */
}
```

**实现原理**：

- 光标位置由 `cur_x`（列）和 `cur_y`（行）表示
- 使用物理屏幕坐标，但通过 `view_offset` 映射到虚拟缓冲区
- 左键在行首时自动跳转到上一行末尾，右键在行末时跳转到下一行开头

**为什么需要这样实现**：

- 类似现代文本编辑器的光标行为，符合用户直觉
- 边界检测防止光标越界
- 使用 `get_line_length()` 限制光标不超过行内容末尾

---

### 2.2 辅助函数

#### `get_line_length()` - 获取行长度

```c
int get_line_length(int virt_y)
{
    int x = NR_CHAR_X - 1;
    while (x >= 0) {
        if (video_buffer[virt_y][x] != ' ')
            return x + 1;
        x--;
    }
    return 0;
}
```

**功能**：从行尾向前扫描，找到最后一个非空字符的位置

#### `get_current_virt_y()` - 获取当前虚拟行号

```c
int get_current_virt_y()
{
    return current_focus->mem_start + 
           current_focus->view_offset + 
           (current_focus->cur_y - current_focus->start_line);
}
```

**功能**：将物理屏幕坐标转换为虚拟缓冲区行号

**计算公式解析**：

- `mem_start`：当前区域在缓冲区中的起始行（上区域=0，下区域=100）
- `view_offset`：视口滚动偏移量
- `cur_y - start_line`：光标相对于区域起始行的偏移

---

## 3. 字符插入删除

### 3.1 字符插入：`insert_char_at()`

**文件位置**：`kernel/excp/exception.c`

```c
void insert_char_at(ConsoleRegion *reg, int virt_y, int x, char c)
{
    // 1. 获取当前行最后一个字符
    char last_char = video_buffer[virt_y][NR_CHAR_X - 1];

    // 2. 行内右移：把 x 之后的字符都往后移一位
    for (int i = NR_CHAR_X - 1; i > x; i--) {
        video_buffer[virt_y][i] = video_buffer[virt_y][i - 1];
    }

    // 3. 插入新字符
    video_buffer[virt_y][x] = c;

    // 4. 处理溢出：如果原末尾有字符，递归插入到下一行
    if (last_char != ' ') {
        int next_virt_y = virt_y + 1;
        if (next_virt_y < reg->mem_start + reg->mem_height) {
            insert_char_at(reg, next_virt_y, 0, last_char);
        }
    }
}
```

**实现原理**：

- 在指定位置插入字符，后续字符整体右移
- 如果行末有字符被挤出，递归插入到下一行开头
- 形成"多行联动"效果，类似文本编辑器的自动换行

**为什么需要递归实现**：

- 当一行满了之后，溢出的字符需要"推"到下一行
- 下一行如果也满了，继续向下推，形成链式反应
- 递归实现代码简洁，逻辑清晰

**协作说明**：此函数直接操作成员 B 管理的 `video_buffer[][]`

---

### 3.2 字符删除：`delete_char_at()`

**文件位置**：`kernel/drv/console.c`

```c
void delete_char_at(ConsoleRegion *reg, int virt_y, int x)
{
    // 1. 行内左移：把 x 之后的字符都往前移一位
    for (int i = x; i < NR_CHAR_X - 1; i++) {
        video_buffer[virt_y][i] = video_buffer[virt_y][i + 1];
    }
    video_buffer[virt_y][NR_CHAR_X - 1] = ' ';

    // 2. 从下一行"借"字符填补本行末尾
    int next_virt_y = virt_y + 1;
    if (next_virt_y < reg->mem_start + reg->mem_height) {
        char next_first = video_buffer[next_virt_y][0];
        if (next_first != ' ') {
            // 找到当前行真正的末尾
            int tail_pos = NR_CHAR_X - 1;
            while (tail_pos >= 0 && video_buffer[virt_y][tail_pos] == ' ')
                tail_pos--;
          
            // 借来的字符放在末尾
            if (tail_pos < NR_CHAR_X - 1)
                video_buffer[virt_y][tail_pos + 1] = next_first;
          
            // 递归：删除下一行的第一个字符
            delete_char_at(reg, next_virt_y, 0);
        }
    }
}
```

**实现原理**：

- 删除指定位置的字符，后续字符左移
- 从下一行"借"第一个字符填补本行末尾空缺
- 形成"多行收缩"效果，与插入操作对称

**为什么需要"借字符"机制**：

- 保持文本的连续性，避免删除后产生断层
- 用户体验更接近现代文本编辑器
- 与 `insert_char_at()` 形成对称的操作逻辑

---

### 3.3 退格处理：`region_putc()` 中的退格逻辑

```c
else if (c == '\b' || c == 127) /* 退格操作 */
{
    if (reg->cur_x > 0) {
        // 情况1：行内删除
        reg->cur_x--;
        delete_char_at(reg, virt_y, reg->cur_x);
    } else {
        // 情况2：行首删除，合并到上一行
        // ... 复杂的跨行合并逻辑
    }
}
```

**行首退格的特殊处理**：

- 光标移动到上一行末尾
- 将当前行内容合并到上一行
- 删除当前行已移走的字符

---

## 4. 特殊功能键处理

### 4.1 焦点切换 (TAB 键)

```c
else if (scan_code == 0x0D) { // Tab
    if (current_focus == &top_region)
        current_focus = &bottom_region;
    else
        current_focus = &top_region;
  
    update_status_bar();       /* 调用成员 B 的函数更新状态栏 */
    flush_screen(&top_region);
    flush_screen(&bottom_region);
}
```

**协作说明**：焦点切换后需要调用成员 B 的刷新函数更新显示

### 4.2 滚动功能 (F1/F2 键)

```c
else if (scan_code == 0x05) { // F1: 向上滚屏
    if (current_focus->view_offset > 0)
        console_scroll(-1);    /* 调用成员 B 的滚动函数 */
}
else if (scan_code == 0x06) { // F2: 向下滚屏
    // 边界检测后调用 console_scroll(1)
}
```

### 4.3 颜色切换 (F3 键)

```c
else if (scan_code == 0x04) { // F3
    static int color_idx = 0;
    set_color(color_idx);
    flush_screen(current_focus);
    update_status_bar();
    color_idx = (color_idx + 1) % 5;
}
```

---

# 第二部分：显示输出模块 (成员 B)

## 1. 虚拟缓冲区管理

### 1.1 数据结构定义

**文件位置**：`kernel/include/console.h`

```c
/* 屏幕物理参数 */
#define NR_PIX_X 1280           /* 水平像素数 */
#define NR_PIX_Y 800            /* 垂直像素数 */
#define NR_BYTE_PIX 4           /* 每像素字节数 (RGBA) */
#define VRAM_BASE 0x40000000UL  /* 显存基地址 */

/* 字符参数 */
#define CHAR_HEIGHT 16          /* 字符高度（像素）*/
#define CHAR_WIDTH 8            /* 字符宽度（像素）*/

/* 屏幕字符容量 */
#define NR_CHAR_X (NR_PIX_X / CHAR_WIDTH)  /* 160 列 */
#define NR_CHAR_Y (NR_PIX_Y / CHAR_HEIGHT) /* 50 行 */

/* 虚拟缓冲区参数 */
#define VIRT_BUFFER_HEIGHT 200  /* 缓冲区总行数 */
```

**屏幕区域结构体**：

```c
typedef struct {
    /* 物理屏幕坐标 */
    int start_line;    /* 区域起始行 */
    int end_line;      /* 区域结束行 */

    /* 虚拟缓冲区管理 */
    int mem_start;     /* 缓冲区起始行下标 */
    int mem_height;    /* 分配的缓冲区行数 */
    int view_offset;   /* 视口偏移量 */

    /* 光标位置 */
    int cur_x;
    int cur_y;

    /* 区域属性 */
    int color;
} ConsoleRegion;
```

**为什么需要这样设计**：

- 分离物理显示和逻辑存储，实现滚动功能
- `view_offset` 控制"窗口"在缓冲区中的位置
- 每个区域独立管理，互不干扰

---

### 1.2 全局缓冲区

**文件位置**：`kernel/drv/console.c`

```c
char video_buffer[VIRT_BUFFER_HEIGHT][NR_CHAR_X]; /* 200行 × 160列 */
ConsoleRegion top_region;                          /* 上半屏 */
ConsoleRegion bottom_region;                       /* 下半屏 */
ConsoleRegion *current_focus;                      /* 当前焦点 */
```

**缓冲区布局**：

```
video_buffer[0-99]   → 上半屏的虚拟缓冲区（100行）
video_buffer[100-199] → 下半屏的虚拟缓冲区（100行）
```

**为什么每个区域分配 100 行**：

- 物理屏幕只显示约 24 行，但缓冲区有 100 行
- 多出的 76 行用于存储滚动历史
- 用户可以通过 F1/F2 键查看历史内容

---

## 2. 分屏功能实现

### 2.1 初始化：`con_init()`

**文件位置**：`kernel/drv/console.c`

```c
void con_init()
{
    /* 清空虚拟缓冲区 */
    for (int y = 0; y < VIRT_BUFFER_HEIGHT; y++)
        for (int x = 0; x < NR_CHAR_X; x++)
            video_buffer[y][x] = ' ';

    /* 上半屏配置 */
    top_region.start_line = 1;    /* 第 1-24 行 (第 0 行是状态栏) */
    top_region.end_line = 24;
    top_region.mem_start = 0;     /* 使用 buffer[0-99] */
    top_region.mem_height = 100;
    top_region.view_offset = 0;
    top_region.cur_x = 0;
    top_region.cur_y = 1;
    top_region.color = MAGENTA;

    /* 下半屏配置 */
    bottom_region.start_line = 26; /* 第 26-49 行 (第 25 行是分隔线) */
    bottom_region.end_line = 49;
    bottom_region.mem_start = 100; /* 使用 buffer[100-199] */
    bottom_region.mem_height = 100;
    bottom_region.view_offset = 0;
    bottom_region.cur_x = 0;
    bottom_region.cur_y = 26;
    bottom_region.color = MAGENTA;

    current_focus = &top_region;
    flush_screen(NULL); /* 全屏刷新 */
}
```

**屏幕布局**：

```
┌────────────────────────────────────────┐
│ 行 0:  状态栏 (MYMQOS Kernel v1.0)      │
├────────────────────────────────────────┤
│ 行 1-24: 上半屏编辑区域                  │
│          (映射到 buffer[0-99])          │
├────────────────────────────────────────┤
│ 行 25:   分隔线 (------------)          │
├────────────────────────────────────────┤
│ 行 26-49: 下半屏编辑区域                 │
│           (映射到 buffer[100-199])      │
└────────────────────────────────────────┘
```

**为什么需要这样布局**：

- 状态栏固定在顶部，显示系统信息和操作提示
- 分隔线视觉上区分两个编辑区域
- 两个区域完全独立，各自有独立的缓冲区

---

### 2.2 状态栏更新：`update_status_bar()`

```c
void update_status_bar()
{
    int y = 0; // 状态栏固定在第 0 行

    // 1. 清空背景
    for (int x = 0; x < NR_CHAR_X; x++)
        write_char_with_color(' ', x, y, BLACK);

    // 2. 左侧：系统名称
    const char *sys_name = "MYMQOS Kernel v1.0";
    for (int i = 0; sys_name[i]; i++)
        write_char_with_color(sys_name[i], 1 + i, y, YELLOW);

    // 3. 中间：当前焦点
    const char *focus_msg = (current_focus == &top_region) 
                          ? "FOCUS: TOP REGION" 
                          : "FOCUS: BOTTOM REGION";
    int center_x = (NR_CHAR_X - msg_len) / 2;
    // ... 绘制焦点信息

    // 4. 右侧：操作提示
    const char *hint = "[F3] Switch Colors  [TAB] Switch Focus  [F1/F2] Scroll";
    // ... 绘制提示信息
}
```

**为什么需要状态栏**：

- 实时显示当前焦点在哪个区域
- 提供操作提示，降低用户学习成本
- 增强用户体验

---

## 3. 屏幕刷新逻辑

### 3.1 主刷新函数：`flush_screen()`

**文件位置**：`kernel/drv/console.c`

```c
void flush_screen(ConsoleRegion *region)
{
    int start_y, end_y;

    if (region == NULL) {
        /* 全屏刷新 */
        update_status_bar();
        start_y = 1;
        end_y = NR_CHAR_Y;
    } else {
        /* 局部刷新 */
        start_y = region->start_line;
        end_y = region->end_line + 1;
    }

    for (int y = start_y; y < end_y; y++) {
        /* 确定当前行属于哪个区域 */
        ConsoleRegion *reg;
        if (y <= top_region.end_line)
            reg = &top_region;
        else if (y >= bottom_region.start_line)
            reg = &bottom_region;
        else {
            /* 绘制分隔线 */
            for (int x = 0; x < NR_CHAR_X; x++)
                write_char_with_color('-', x, y, WHITE);
            continue;
        }

        /* 计算虚拟缓冲区行号 */
        int virt_y = reg->mem_start + reg->view_offset + (y - reg->start_line);

        /* 绘制当前行 */
        for (int x = 0; x < NR_CHAR_X; x++) {
            char c = video_buffer[virt_y][x];
            enum COLOR color = reg->color;

            /* 光标位置特殊处理 */
            if (current_focus == reg && x == reg->cur_x && y == reg->cur_y) {
                if (c == ' ')
                    write_char_with_color('_', x, y, WHITE);
                else
                    write_char_with_color(c, x, y, WHITE);
            } else {
                write_char_with_color(c, x, y, color);
            }
        }
    }
}
```

**实现原理**：

1. 支持全屏刷新（`region = NULL`）和局部刷新
2. 根据物理行号判断属于哪个区域
3. 通过 `view_offset` 计算对应的虚拟缓冲区行
4. 光标位置用下划线 `_` 或白色字符高亮显示

**为什么需要局部刷新**：

- 全屏刷新效率低，每次按键都刷新 8000 个字符 (160×50)
- 局部刷新只刷新当前聚焦区域，大幅提升性能
- 光标移动、字符输入等操作只需刷新一个区域

**协作说明**：此函数读取成员 A 更新的光标位置 (`cur_x`, `cur_y`) 来绘制光标

---

### 3.2 底层绘制：`write_char_with_color()`

```c
void write_char_with_color(char ascii, int xx, int yy, enum COLOR color)
{
    char *font_byte;
    struct RGB col_rgb = color_map[color];

    /* 获取字体数据 */
    font_byte = &fonts[(ascii - 32) * CHAR_HEIGHT];
  
    /* 计算显存位置 */
    char *pos = (char *)(VRAM_BASE + 
                (yy * CHAR_HEIGHT * NR_PIX_X + xx * CHAR_WIDTH) * NR_BYTE_PIX);

    /* 逐像素绘制 */
    for (int row = 0; row < CHAR_HEIGHT; row++, font_byte++) {
        for (int col = 0; col < CHAR_WIDTH; col++) {
            if (*font_byte & (1 << (7 - col))) {
                /* 前景色 */
                *pos++ = col_rgb.r;
                *pos++ = col_rgb.g;
                *pos++ = col_rgb.b;
                *pos++ = col_rgb.a;
            } else {
                /* 背景色（黑色）*/
                *pos++ = 0;
                *pos++ = 0;
                *pos++ = 0;
                *pos++ = 0;
            }
        }
        pos += (NR_PIX_X - CHAR_WIDTH) * NR_BYTE_PIX;
    }
}
```

**实现原理**：

- 字体存储为 8×16 像素的点阵，每行用 1 字节表示
- 每个字符占用 `CHAR_WIDTH × CHAR_HEIGHT × 4` 字节显存
- 直接操作显存地址 `0x40000000` 进行像素级绘制

**为什么使用点阵字体**：

- 操作系统内核环境无法使用矢量字体库
- 点阵字体简单高效，直接映射到显存
- 支持 ASCII 32-126 的所有可打印字符

---

## 4. 视口滚动

### 4.1 滚动函数：`console_scroll()`

```c
void console_scroll(int direction)
{
    if (!current_focus) return;

    ConsoleRegion *reg = current_focus;
    int screen_height = reg->end_line - reg->start_line + 1;

    if (direction < 0) {  /* 向上滚动（看历史）*/
        if (reg->view_offset > 0)
            reg->view_offset--;
    } else {              /* 向下滚动（看新内容）*/
        if (reg->view_offset + screen_height < reg->mem_height)
            reg->view_offset++;
    }
  
    flush_screen(current_focus);
}
```

**滚动机制图解**：

```
                    缓冲区 (100行)
                ┌───────────────────┐
                │ 行 0: 历史内容...  │
                │ 行 1: ...         │
                │ ...               │
view_offset=0 → │ 行 0              │ ← 屏幕显示的第一行
                │ 行 1              │
                │ ...               │
                │ 行 23             │ ← 屏幕显示的最后一行
                │ ...               │
                │ 行 99: 最新内容    │
                └───────────────────┘

按 F1 后: view_offset 减 1，窗口向上移动
按 F2 后: view_offset 加 1，窗口向下移动
```

**为什么需要 view_offset**：

- 物理屏幕只能显示 24 行，但缓冲区有 100 行
- `view_offset` 控制显示窗口在缓冲区中的起始位置
- 用户可以"回看"历史输入，类似终端的滚动功能

---

## 5. 字符颜色管理

### 5.1 颜色映射表

```c
struct RGB color_map[] = {
    {255, 0, 0, 0},     // RED
    {0, 255, 0, 0},     // GREEN
    {255, 255, 0, 0},   // YELLOW
    {0, 255, 255, 0},   // CYAN
    {255, 0, 255, 0},   // MAGENTA
    {255, 255, 255, 0}, // WHITE
    {0, 0, 0, 0}        // BLACK
};
```

### 5.2 颜色设置：`set_color()`

```c
void set_color(enum COLOR color)
{
    if (current_focus)
        current_focus->color = color;
}
```

**协作说明**：成员 A 的 F3 按键处理调用此函数，成员 B 在刷新时使用颜色值

---

## 6. 字体数据

**文件位置**：`kernel/drv/font.c`

```c
char fonts[] = {
    // 每个字符 16 字节，共 95 个可打印 ASCII 字符
    0x00, 0x00, ..., // 32: ' ' (空格)
    0x00, 0x00, ..., // 33: '!'
    // ...
    0x00, 0x76, ..., // 126: '~'
};
```

字体数据格式：每个字符 16 行，每行 1 字节（8 像素），位图表示。

---

# 第三部分：模块协作关系

## 1. 函数调用关系图

```
┌─────────────────────────────────────────────────────────────────┐
│                        成员 A (逻辑控制)                         │
├─────────────────────────────────────────────────────────────────┤
│  key_interrupt()                                                │
│       │                                                         │
│       └──► handle_editor_input()                                │
│                 │                                               │
│                 ├──► insert_char_at() ──────────────────┐      │
│                 │         │                              │      │
│                 │         └──► video_buffer[][] ◄────────┤      │
│                 │                                        │      │
│                 ├──► delete_char_at() ──────────────────┤      │
│                 │                                        │      │
│                 └──► flush_screen() ─────────────────────┤      │
│                                                          │      │
└──────────────────────────────────────────────────────────┼──────┘
                                                           │
                    ┌──────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────┐
│                        成员 B (显示输出)                         │
├─────────────────────────────────────────────────────────────────┤
│  video_buffer[200][160]  ◄── 数据存储层                         │
│       │                                                         │
│       ▼                                                         │
│  flush_screen()                                                 │
│       │                                                         │
│       ├──► update_status_bar()                                  │
│       │                                                         │
│       └──► write_char_with_color()                              │
│                 │                                               │
│                 └──► VRAM (0x40000000)                          │
│                                                                 │
│  console_scroll()  ◄── 视口控制                                  │
│  con_init()        ◄── 系统初始化                                │
│  set_color()       ◄── 属性设置                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 数据流向

```
用户按键
    │
    ▼
PS/2 扫描码 ──► key_interrupt() [成员 A]
    │
    ▼
handle_editor_input() [成员 A]
    │
    ├───► 光标移动：修改 cur_x, cur_y
    │
    ├───► 字符输入：insert_char_at() ──► video_buffer [成员 B]
    │
    ├───► 字符删除：delete_char_at() ──► video_buffer [成员 B]
    │
    └───► flush_screen() [成员 B]
              │
              ├───► 读取 video_buffer
              │
              ├───► 读取 cur_x, cur_y（绘制光标）
              │
              └───► write_char_with_color() ──► VRAM
                                                  │
                                                  ▼
                                              显示器输出
```

---

## 3. 关键协作点

| 协作点               | 成员 A 职责                                              | 成员 B 职责                          |
| -------------------- | -------------------------------------------------------- | ------------------------------------ |
| **缓冲区操作** | 调用 `insert_char_at()`、`delete_char_at()` 修改数据 | 提供 `video_buffer[][]` 存储结构   |
| **光标显示**   | 维护 `cur_x`、`cur_y` 位置                           | 在 `flush_screen()` 中高亮显示光标 |
| **屏幕刷新**   | 在输入处理后调用 `flush_screen()`                      | 实现刷新逻辑，将缓冲区内容绘制到显存 |
| **焦点切换**   | 处理 TAB 键，修改 `current_focus`                      | 在状态栏显示当前焦点                 |
| **颜色切换**   | 处理 F3 键，调用 `set_color()`                         | 实现颜色存储和绘制                   |
| **滚动功能**   | 处理 F1/F2 键，调用 `console_scroll()`                 | 实现视口偏移计算和重绘               |

---

## 4. 接口定义

### 成员 A 提供给成员 B 的接口

```c
/* 光标位置（通过 ConsoleRegion 结构体共享）*/
current_focus->cur_x  /* 当前列 */
current_focus->cur_y  /* 当前行 */
```

### 成员 B 提供给成员 A 的接口

```c
/* 缓冲区访问 */
extern char video_buffer[VIRT_BUFFER_HEIGHT][NR_CHAR_X];

/* 屏幕区域 */
extern ConsoleRegion top_region;
extern ConsoleRegion bottom_region;
extern ConsoleRegion *current_focus;

/* 核心函数 */
void flush_screen(ConsoleRegion *region);  /* 刷新屏幕 */
void console_scroll(int direction);         /* 滚动视口 */
void update_status_bar(void);               /* 更新状态栏 */
void set_color(enum COLOR color);           /* 设置颜色 */
void delete_char_at(ConsoleRegion *reg, int virt_y, int x); /* 删除字符 */
```

---

# 第四部分：系统启动流程

```
                    电源开启
                        │
                        ▼
                ┌───────────────┐
                │    BIOS/UEFI  │
                └───────┬───────┘
                        │
                        ▼
                ┌───────────────┐
                │   head.S      │  设置栈指针
                │   _start      │  跳转到 main
                └───────┬───────┘
                        │
                        ▼
                ┌───────────────┐
                │   main.c      │
                │   main()      │
                └───────┬───────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
        ▼               ▼               ▼
   excp_init()    con_init()       int_on()
   [成员 A]        [成员 B]        [成员 A]
        │               │               │
        │               │               │
        ▼               ▼               │
   配置中断       初始化分屏            │
   入口地址       清空缓冲区            │
        │               │               │
        └───────────────┴───────────────┘
                        │
                        ▼
                ┌───────────────┐
                │  主循环等待    │
                │  while(1)     │
                └───────────────┘
                        │
                        ▼ (中断发生)
                ┌───────────────┐
                │ 键盘输入处理   │
                │ [成员 A + B]  │
                └───────────────┘
```

---

# 附录

## A. 文件结构

```
kernel/
├── Makefile                    # 编译脚本
├── init/
│   ├── head.S                  # 启动入口（汇编）
│   └── main.c                  # 主函数
├── drv/
│   ├── console.c               # 显示驱动（成员 B）
│   └── font.c                  # 字体数据
├── excp/
│   ├── exception.c             # 异常处理（成员 A）
│   └── exception_handler.S     # 异常入口（汇编）
├── include/
│   ├── console.h               # 控制台头文件
│   ├── exception.h             # 异常头文件
│   └── xtos.h                  # 系统工具函数
└── mm/
    └── memory.c                # 内存管理（预留）
```

## B. 编译与运行

```bash
# 编译内核
cd kernel
make clean
make

# 运行 QEMU
cd ../run
./run.sh
```

## C. 操作说明

| 按键        | 功能                 |
| ----------- | -------------------- |
| A-Z, 0-9 等 | 输入字符             |
| ↑ ↓ ← → | 移动光标             |
| Backspace   | 删除字符             |
| Enter       | 换行                 |
| TAB         | 切换上下窗口焦点     |
| F1          | 向上滚动（查看历史） |
| F2          | 向下滚动             |
| F3          | 切换字符颜色         |
| CapsLock    | 大小写切换           |

---

## D. 技术规格

| 参数       | 值               |
| ---------- | ---------------- |
| 架构       | LoongArch64      |
| 分辨率     | 1280 × 800      |
| 字符尺寸   | 8 × 16 像素     |
| 屏幕容量   | 160 列 × 50 行  |
| 缓冲区大小 | 200 行 × 160 列 |
| 显存地址   | 0x40000000       |
| 颜色模式   | 32位 RGBA        |

---

*文档版本: 1.0*
*最后更新: 2026年1月3日*
